<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AR Pet Pals Doxygen: UnityEngine.InputSystem.InputAction Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AR Pet Pals Doxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceUnityEngine.html">UnityEngine</a></li><li class="navelem"><a class="el" href="namespaceUnityEngine_1_1InputSystem.html">InputSystem</a></li><li class="navelem"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="classUnityEngine_1_1InputSystem_1_1InputAction-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">UnityEngine.InputSystem.InputAction Class Reference<span class="mlabels"><span class="mlabel">sealed</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A named input signal that can flexibly decide which input data to tap.  
 <a href="classUnityEngine_1_1InputSystem_1_1InputAction.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for UnityEngine.InputSystem.InputAction:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classUnityEngine_1_1InputSystem_1_1InputAction.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUnityEngine_1_1InputSystem_1_1InputAction_1_1CallbackContext.html">CallbackContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information provided to action callbacks about what triggered an action.  <a href="structUnityEngine_1_1InputSystem_1_1InputAction_1_1CallbackContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae837b4878d72f5557c81534ce5a50497" id="r_ae837b4878d72f5557c81534ce5a50497"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#ae837b4878d72f5557c81534ce5a50497">InputAction</a> ()</td></tr>
<tr class="memdesc:ae837b4878d72f5557c81534ce5a50497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an unnamed, free-standing action that is not part of any map or asset and has no bindings. Bindings can be added with InputActionSetupExtensions.AddBinding(InputAction,string,string,string,string). The action type defaults to InputActionType.Value.  <br /></td></tr>
<tr class="separator:ae837b4878d72f5557c81534ce5a50497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d5a10b601f0956619cda9a5af9f51e" id="r_a76d5a10b601f0956619cda9a5af9f51e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a76d5a10b601f0956619cda9a5af9f51e">InputAction</a> (string <a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a18e68eda84c66e46fc7908fe67b8ffce">name</a>=null, <a class="el" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94b">InputActionType</a> <a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a4034bbebc91379913a9da5600a8a3491">type</a>=default, string binding=null, string <a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a625a03ad3baab2c78b68cc782ca25458">interactions</a>=null, string <a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a02b761c2f6c76c80c3c4b1cd396df3c4">processors</a>=null, string <a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#ab0330ac2a9ede3454cb0c092ac0a7bcb">expectedControlType</a>=null)</td></tr>
<tr class="memdesc:a76d5a10b601f0956619cda9a5af9f51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a free-standing action that is not part of an InputActionMap.  <br /></td></tr>
<tr class="separator:a76d5a10b601f0956619cda9a5af9f51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c45bb13be7dafd32a3cfd23ba85a80e" id="r_a5c45bb13be7dafd32a3cfd23ba85a80e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a5c45bb13be7dafd32a3cfd23ba85a80e">Dispose</a> ()</td></tr>
<tr class="memdesc:a5c45bb13be7dafd32a3cfd23ba85a80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release internal state held on to by the action.  <br /></td></tr>
<tr class="separator:a5c45bb13be7dafd32a3cfd23ba85a80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a705ae3957bdb7d38380b7528b44c9" id="r_a30a705ae3957bdb7d38380b7528b44c9"><td class="memItemLeft" align="right" valign="top">override string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a30a705ae3957bdb7d38380b7528b44c9">ToString</a> ()</td></tr>
<tr class="memdesc:a30a705ae3957bdb7d38380b7528b44c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string version of the action. Mainly useful for debugging.  <br /></td></tr>
<tr class="separator:a30a705ae3957bdb7d38380b7528b44c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6ff7728cbf947406b3c426cf82437f" id="r_abc6ff7728cbf947406b3c426cf82437f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#abc6ff7728cbf947406b3c426cf82437f">Enable</a> ()</td></tr>
<tr class="memdesc:abc6ff7728cbf947406b3c426cf82437f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the action such that it actively listens for input and runs callbacks in response.  <br /></td></tr>
<tr class="separator:abc6ff7728cbf947406b3c426cf82437f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301a6f1f456e71eee25363f62861ff93" id="r_a301a6f1f456e71eee25363f62861ff93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a301a6f1f456e71eee25363f62861ff93">Disable</a> ()</td></tr>
<tr class="memdesc:a301a6f1f456e71eee25363f62861ff93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the action such that is stop listening/responding to input.  <br /></td></tr>
<tr class="separator:a301a6f1f456e71eee25363f62861ff93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89e9c5f63ab9f09fe169fd082e40c35" id="r_ab89e9c5f63ab9f09fe169fd082e40c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#ab89e9c5f63ab9f09fe169fd082e40c35">Clone</a> ()</td></tr>
<tr class="memdesc:ab89e9c5f63ab9f09fe169fd082e40c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an identical instance of the action.  <br /></td></tr>
<tr class="separator:ab89e9c5f63ab9f09fe169fd082e40c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b189fd9d09cc28efd17c08a17eeb0c" id="r_a49b189fd9d09cc28efd17c08a17eeb0c"><td class="memItemLeft" align="right" valign="top">unsafe TValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a49b189fd9d09cc28efd17c08a17eeb0c">ReadValue&lt; TValue &gt;</a> ()</td></tr>
<tr class="memdesc:a49b189fd9d09cc28efd17c08a17eeb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of the control that is driving this action. If no bound control is actuated, returns default(TValue), but note that binding processors are always applied.  <br /></td></tr>
<tr class="separator:a49b189fd9d09cc28efd17c08a17eeb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b48d7c58238d51f0ff1c708aa360da" id="r_a46b48d7c58238d51f0ff1c708aa360da"><td class="memItemLeft" align="right" valign="top">unsafe object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a46b48d7c58238d51f0ff1c708aa360da">ReadValueAsObject</a> ()</td></tr>
<tr class="memdesc:a46b48d7c58238d51f0ff1c708aa360da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ReadValue&lt;TValue&gt; but read the value without having to know the value type of the action.  <br /></td></tr>
<tr class="separator:a46b48d7c58238d51f0ff1c708aa360da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734e734be5da00df41bb4a0c02ffe7a5" id="r_a734e734be5da00df41bb4a0c02ffe7a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a734e734be5da00df41bb4a0c02ffe7a5">Reset</a> ()</td></tr>
<tr class="memdesc:a734e734be5da00df41bb4a0c02ffe7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the action state to default.  <br /></td></tr>
<tr class="separator:a734e734be5da00df41bb4a0c02ffe7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba2a7836129d30d4996714c3e3f871d" id="r_a4ba2a7836129d30d4996714c3e3f871d"><td class="memItemLeft" align="right" valign="top">unsafe bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a4ba2a7836129d30d4996714c3e3f871d">IsPressed</a> ()</td></tr>
<tr class="memdesc:a4ba2a7836129d30d4996714c3e3f871d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the current actuation of the action has crossed the button press threshold (see InputSettings.defaultButtonPressPoint) and has not yet fallen back below the release threshold (see InputSettings.buttonReleaseThreshold).  <br /></td></tr>
<tr class="separator:a4ba2a7836129d30d4996714c3e3f871d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e3c5225e7a6da527e07aeea65b6800" id="r_a39e3c5225e7a6da527e07aeea65b6800"><td class="memItemLeft" align="right" valign="top">unsafe bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a39e3c5225e7a6da527e07aeea65b6800">IsInProgress</a> ()</td></tr>
<tr class="memdesc:a39e3c5225e7a6da527e07aeea65b6800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the action has been InputActionPhase.Started or InputActionPhase.Performed.  <br /></td></tr>
<tr class="separator:a39e3c5225e7a6da527e07aeea65b6800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7776c9dbaab7db1f49493c6e7e8c4fbb" id="r_a7776c9dbaab7db1f49493c6e7e8c4fbb"><td class="memItemLeft" align="right" valign="top">unsafe bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a7776c9dbaab7db1f49493c6e7e8c4fbb">WasPressedThisFrame</a> ()</td></tr>
<tr class="memdesc:a7776c9dbaab7db1f49493c6e7e8c4fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the action's value crossed the press threshold (see InputSettings.defaultButtonPressPoint) at any point in the frame.  <br /></td></tr>
<tr class="separator:a7776c9dbaab7db1f49493c6e7e8c4fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aa02b5124108b0fd9ecc74e919ee9b" id="r_aa0aa02b5124108b0fd9ecc74e919ee9b"><td class="memItemLeft" align="right" valign="top">unsafe bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#aa0aa02b5124108b0fd9ecc74e919ee9b">WasReleasedThisFrame</a> ()</td></tr>
<tr class="memdesc:aa0aa02b5124108b0fd9ecc74e919ee9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the action's value crossed the release threshold (see InputSettings.buttonReleaseThreshold) at any point in the frame after being in pressed state.  <br /></td></tr>
<tr class="separator:aa0aa02b5124108b0fd9ecc74e919ee9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1968a212ee4e88950b4f1f15043a9d42" id="r_a1968a212ee4e88950b4f1f15043a9d42"><td class="memItemLeft" align="right" valign="top">unsafe bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a1968a212ee4e88950b4f1f15043a9d42">WasPerformedThisFrame</a> ()</td></tr>
<tr class="memdesc:a1968a212ee4e88950b4f1f15043a9d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether phase was InputActionPhase.Performed at any point in the current frame.  <br /></td></tr>
<tr class="separator:a1968a212ee4e88950b4f1f15043a9d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2970b93407d558ab7de5806599dce7" id="r_a5d2970b93407d558ab7de5806599dce7"><td class="memItemLeft" align="right" valign="top">unsafe float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a5d2970b93407d558ab7de5806599dce7">GetTimeoutCompletionPercentage</a> ()</td></tr>
<tr class="memdesc:a5d2970b93407d558ab7de5806599dce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the completion percentage of the timeout (if any) running on the current interaction.  <br /></td></tr>
<tr class="separator:a5d2970b93407d558ab7de5806599dce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="properties" name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a18e68eda84c66e46fc7908fe67b8ffce" id="r_a18e68eda84c66e46fc7908fe67b8ffce"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a18e68eda84c66e46fc7908fe67b8ffce">name</a><code> [get]</code></td></tr>
<tr class="memdesc:a18e68eda84c66e46fc7908fe67b8ffce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the action.  <br /></td></tr>
<tr class="separator:a18e68eda84c66e46fc7908fe67b8ffce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4034bbebc91379913a9da5600a8a3491" id="r_a4034bbebc91379913a9da5600a8a3491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94b">InputActionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a4034bbebc91379913a9da5600a8a3491">type</a><code> [get]</code></td></tr>
<tr class="memdesc:a4034bbebc91379913a9da5600a8a3491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Behavior type of the action.  <br /></td></tr>
<tr class="separator:a4034bbebc91379913a9da5600a8a3491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c55a69282fe033ba0ca4ce706e4a68" id="r_a20c55a69282fe033ba0ca4ce706e4a68"><td class="memItemLeft" align="right" valign="top">Guid&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a20c55a69282fe033ba0ca4ce706e4a68">id</a><code> [get]</code></td></tr>
<tr class="memdesc:a20c55a69282fe033ba0ca4ce706e4a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stable, unique identifier for the action.  <br /></td></tr>
<tr class="separator:a20c55a69282fe033ba0ca4ce706e4a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0330ac2a9ede3454cb0c092ac0a7bcb" id="r_ab0330ac2a9ede3454cb0c092ac0a7bcb"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#ab0330ac2a9ede3454cb0c092ac0a7bcb">expectedControlType</a><code> [get, set]</code></td></tr>
<tr class="memdesc:ab0330ac2a9ede3454cb0c092ac0a7bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of control layout expected for controls bound to this action.  <br /></td></tr>
<tr class="separator:ab0330ac2a9ede3454cb0c092ac0a7bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b761c2f6c76c80c3c4b1cd396df3c4" id="r_a02b761c2f6c76c80c3c4b1cd396df3c4"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a02b761c2f6c76c80c3c4b1cd396df3c4">processors</a><code> [get]</code></td></tr>
<tr class="memdesc:a02b761c2f6c76c80c3c4b1cd396df3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processors applied to every binding on the action.  <br /></td></tr>
<tr class="separator:a02b761c2f6c76c80c3c4b1cd396df3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625a03ad3baab2c78b68cc782ca25458" id="r_a625a03ad3baab2c78b68cc782ca25458"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a625a03ad3baab2c78b68cc782ca25458">interactions</a><code> [get]</code></td></tr>
<tr class="memdesc:a625a03ad3baab2c78b68cc782ca25458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interactions applied to every binding on the action.  <br /></td></tr>
<tr class="separator:a625a03ad3baab2c78b68cc782ca25458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6817835d32520aa1433e7119c6e30e8" id="r_ae6817835d32520aa1433e7119c6e30e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputActionMap.html">InputActionMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#ae6817835d32520aa1433e7119c6e30e8">actionMap</a><code> [get]</code></td></tr>
<tr class="memdesc:ae6817835d32520aa1433e7119c6e30e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map the action belongs to.  <br /></td></tr>
<tr class="separator:ae6817835d32520aa1433e7119c6e30e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41caa3a44bc876781c5b1bcb04622cd2" id="r_a41caa3a44bc876781c5b1bcb04622cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUnityEngine_1_1InputSystem_1_1InputBinding.html">InputBinding</a>?&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a41caa3a44bc876781c5b1bcb04622cd2">bindingMask</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a41caa3a44bc876781c5b1bcb04622cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional mask that determines which bindings of the action to enable and which to ignore.  <br /></td></tr>
<tr class="separator:a41caa3a44bc876781c5b1bcb04622cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fdaf3ff9ffc22609a9df942372d9bb" id="r_a44fdaf3ff9ffc22609a9df942372d9bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUnityEngine_1_1InputSystem_1_1Utilities_1_1ReadOnlyArray.html">ReadOnlyArray</a>&lt; <a class="el" href="structUnityEngine_1_1InputSystem_1_1InputBinding.html">InputBinding</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a44fdaf3ff9ffc22609a9df942372d9bb">bindings</a><code> [get]</code></td></tr>
<tr class="memdesc:a44fdaf3ff9ffc22609a9df942372d9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of bindings associated with the action.  <br /></td></tr>
<tr class="separator:a44fdaf3ff9ffc22609a9df942372d9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3f5d3329be13ca8474314137045af4" id="r_a8e3f5d3329be13ca8474314137045af4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUnityEngine_1_1InputSystem_1_1Utilities_1_1ReadOnlyArray.html">ReadOnlyArray</a>&lt; <a class="el" href="classUnityEngine_1_1InputSystem_1_1InputControl.html">InputControl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a8e3f5d3329be13ca8474314137045af4">controls</a><code> [get]</code></td></tr>
<tr class="memdesc:a8e3f5d3329be13ca8474314137045af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of controls to which the action's bindings resolve.  <br /></td></tr>
<tr class="separator:a8e3f5d3329be13ca8474314137045af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bd545c9dfe1fb0200e296c44389e57" id="r_a86bd545c9dfe1fb0200e296c44389e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceUnityEngine_1_1InputSystem.html#aecc012480a29c4b720a87b8465f34182">InputActionPhase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a86bd545c9dfe1fb0200e296c44389e57">phase</a><code> [get]</code></td></tr>
<tr class="memdesc:a86bd545c9dfe1fb0200e296c44389e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current phase of the action.  <br /></td></tr>
<tr class="separator:a86bd545c9dfe1fb0200e296c44389e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f170acb40585d0ce4f6c2243b5b213" id="r_ad3f170acb40585d0ce4f6c2243b5b213"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#ad3f170acb40585d0ce4f6c2243b5b213">inProgress</a><code> [get]</code></td></tr>
<tr class="memdesc:ad3f170acb40585d0ce4f6c2243b5b213"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the action is currently in InputActionPhase.Started or InputActionPhase.Performed phase. False in all other cases.  <br /></td></tr>
<tr class="separator:ad3f170acb40585d0ce4f6c2243b5b213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b7ab479ef1419726f2d05927fd1b70" id="r_a10b7ab479ef1419726f2d05927fd1b70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a10b7ab479ef1419726f2d05927fd1b70">enabled</a><code> [get]</code></td></tr>
<tr class="memdesc:a10b7ab479ef1419726f2d05927fd1b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the action is currently enabled, i.e. responds to input, or not.  <br /></td></tr>
<tr class="separator:a10b7ab479ef1419726f2d05927fd1b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fecf2acd129fa0922452ecf32527cdd" id="r_a5fecf2acd129fa0922452ecf32527cdd"><td class="memItemLeft" align="right" valign="top">Action&lt; <a class="el" href="structUnityEngine_1_1InputSystem_1_1InputAction_1_1CallbackContext.html">CallbackContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a5fecf2acd129fa0922452ecf32527cdd">started</a></td></tr>
<tr class="memdesc:a5fecf2acd129fa0922452ecf32527cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event that is triggered when the action has been started.  <br /></td></tr>
<tr class="separator:a5fecf2acd129fa0922452ecf32527cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905374d6d7af6dc57a54acfa22018976" id="r_a905374d6d7af6dc57a54acfa22018976"><td class="memItemLeft" align="right" valign="top">Action&lt; <a class="el" href="structUnityEngine_1_1InputSystem_1_1InputAction_1_1CallbackContext.html">CallbackContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a905374d6d7af6dc57a54acfa22018976">canceled</a></td></tr>
<tr class="memdesc:a905374d6d7af6dc57a54acfa22018976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event that is triggered when the action has been started but then canceled before being fully performed.  <br /></td></tr>
<tr class="separator:a905374d6d7af6dc57a54acfa22018976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c046d8fb911d300e30e67827222c1f" id="r_a11c046d8fb911d300e30e67827222c1f"><td class="memItemLeft" align="right" valign="top">Action&lt; <a class="el" href="structUnityEngine_1_1InputSystem_1_1InputAction_1_1CallbackContext.html">CallbackContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a11c046d8fb911d300e30e67827222c1f">performed</a></td></tr>
<tr class="memdesc:a11c046d8fb911d300e30e67827222c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event that is triggered when the action has been fully performed.  <br /></td></tr>
<tr class="separator:a11c046d8fb911d300e30e67827222c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae559389a3ace0bdfc463ac56bf57632b" id="r_ae559389a3ace0bdfc463ac56bf57632b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#ae559389a3ace0bdfc463ac56bf57632b">triggered</a><code> [get]</code></td></tr>
<tr class="memdesc:ae559389a3ace0bdfc463ac56bf57632b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to WasPerformedThisFrame.  <br /></td></tr>
<tr class="separator:ae559389a3ace0bdfc463ac56bf57632b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472cf9d7e67051b780bca5df73c7bb84" id="r_a472cf9d7e67051b780bca5df73c7bb84"><td class="memItemLeft" align="right" valign="top">unsafe <a class="el" href="classUnityEngine_1_1InputSystem_1_1InputControl.html">InputControl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a472cf9d7e67051b780bca5df73c7bb84">activeControl</a><code> [get]</code></td></tr>
<tr class="memdesc:a472cf9d7e67051b780bca5df73c7bb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently active control that is driving the action. Null while the action is in waiting (InputActionPhase.Waiting) or canceled (InputActionPhase.Canceled) state. Otherwise the control that last had activity on it which wasn't ignored.  <br /></td></tr>
<tr class="separator:a472cf9d7e67051b780bca5df73c7bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2978b2fcba4145ce4213df097c298a98" id="r_a2978b2fcba4145ce4213df097c298a98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#a2978b2fcba4145ce4213df097c298a98">wantsInitialStateCheck</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a2978b2fcba4145ce4213df097c298a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the action wants a state check on its bound controls as soon as it is enabled. This is always true for InputActionType.Value actions but can optionally be enabled for InputActionType.Button or InputActionType.PassThrough actions.  <br /></td></tr>
<tr class="separator:a2978b2fcba4145ce4213df097c298a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A named input signal that can flexibly decide which input data to tap. </p>
<p>An input action is an abstraction over the source of input(s) it receives. They are most useful for representing input as "logical" concepts (e.g. "jump") rather than as "physical" inputs (e.g. "space bar on keyboard pressed").</p>
<p>In its most basic form, an action is simply an object along with a collection of bindings that trigger the action.</p>
<div class="fragment"><div class="line"><span class="comment">// A simple action can be created directly using &lt;tt&gt;new&lt;/tt&gt;. If desired, a binding</span></div>
<div class="line"><span class="comment">// can be specified directly as part of construction.</span></div>
<div class="line">var action = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>(binding: <span class="stringliteral">&quot;&lt;Gamepad&gt;/buttonSouth&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Additional bindings can be added using &lt;tt&gt;AddBinding&lt;/tt&gt;.</span></div>
<div class="line">action.AddBinding(<span class="stringliteral">&quot;&lt;Mouse&gt;/leftButton&quot;</span>);</div>
<div class="ttc" id="aclassUnityEngine_1_1InputSystem_1_1InputAction_html"><div class="ttname"><a href="classUnityEngine_1_1InputSystem_1_1InputAction.html">UnityEngine.InputSystem.InputAction</a></div><div class="ttdoc">A named input signal that can flexibly decide which input data to tap.</div><div class="ttdef"><b>Definition</b> InputAction.cs:168</div></div>
</div><!-- fragment --> <p>Bindings use control path expressions to reference controls. See InputBinding for more details. There may be arbitrary many bindings targeting a single action. The list of bindings targeting an action can be obtained through bindings.</p>
<p>By itself an action does not do anything until it is enabled:</p>
<div class="fragment"><div class="line">action.Enable();</div>
</div><!-- fragment --> <p>Once enabled, the action will actively monitor all controls on devices present in the system (see InputSystem.devices) that match any of the binding paths associated with the action. If you want to restrict the set of bindings used at runtime or restrict the set of devices which controls are chosen from, you can do so using bindingMask or, if the action is part of an InputActionMap, by setting the InputActionMap.devices property of the action map. The controls that an action uses can be queried using the controls property.</p>
<p>When input is received on controls bound to an action, the action will trigger callbacks in response. These callbacks are started, performed, and canceled. The callbacks are triggered as part of input system updates (see InputSystem.Update), i.e. they happen before the respective <code>MonoBehaviour.Update</code> or <code>MonoBehaviour.FixedUpdate</code> methods get executed (depending on which InputSettings.updateMode the system is set to).</p>
<p>In what order and how those callbacks get triggered depends on both the type of the action as well as on the interactions (see IInputInteraction) present on the bindings of the action. The default behavior is that when a control is actuated (that is, moving away from its resting position), started is called and then performed. Subsequently, whenever the a control further changes value to anything other than its default value, performed will be called again. Finally, when the control moves back to its default value (i.e. resting position), canceled is called.</p>
<p>To hook into the callbacks, there are several options available to you. The most obvious one is to hook directly into started, performed, and/or canceled. In these callbacks, you will receive a CallbackContext with information about how the action got triggered. For example, you can use CallbackContext.ReadValue&lt;TValue&gt; to read the value from the binding that triggered or use CallbackContext.interaction to find the interaction that is in progress.</p>
<div class="fragment"><div class="line">action.started += context =&gt; Debug.Log($<span class="stringliteral">&quot;{context.action} started&quot;</span>);</div>
<div class="line">action.performed += context =&gt; Debug.Log($<span class="stringliteral">&quot;{context.action} performed&quot;</span>);</div>
<div class="line">action.canceled += context =&gt; Debug.Log($<span class="stringliteral">&quot;{context.action} canceled&quot;</span>);</div>
</div><!-- fragment --> <p>Alternatively, you can use the InputActionMap.actionTriggered callback for actions that are part of an action map or the global InputSystem.onActionChange callback to globally listen for action activity. To simply record action activity instead of responding to it directly, you can use InputActionTrace.</p>
<p>If you prefer to poll an action directly as part of your <code>MonoBehaviour.Update</code> or <code>MonoBehaviour.FixedUpdate</code> logic, you can do so using the triggered and ReadValue&lt;TValue&gt; methods.</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span> <span class="keywordtype">void</span> Update()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// For a button type action.</span></div>
<div class="line">    <span class="keywordflow">if</span> (action.triggered)</div>
<div class="line">        <span class="comment">/* ... *&amp;zwj;/;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    // For a value type action.</span></div>
<div class="line"><span class="comment">    // (Vector2 is just an example; pick the value type that is the right</span></div>
<div class="line"><span class="comment">    // one according to the bindings you have)</span></div>
<div class="line"><span class="comment">    var v = action.ReadValue&lt;Vector2&gt;();</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --> <p>Note that actions are not generally frame-based. What this means is that an action will observe any value change on its connected controls, even if the control changes value multiple times in the same frame. In practice, this means that, for example, no button press will get missed.</p>
<p>Actions can be grouped into maps (see InputActionMap) which can in turn be grouped into assets (see InputActionAsset).</p>
<p>Please note that actions are a player-only feature. They are not supported in edit mode.</p>
<p>For more in-depth reading on actions, see the <a href="../manual/Actions.html">manual</a>. </p>
<dl class="section see"><dt>See also</dt><dd>InputActionMap, InputActionAsset, InputBinding</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae837b4878d72f5557c81534ce5a50497" name="ae837b4878d72f5557c81534ce5a50497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae837b4878d72f5557c81534ce5a50497">&#9670;&#160;</a></span>InputAction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnityEngine.InputSystem.InputAction.InputAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an unnamed, free-standing action that is not part of any map or asset and has no bindings. Bindings can be added with InputActionSetupExtensions.AddBinding(InputAction,string,string,string,string). The action type defaults to InputActionType.Value. </p>
<p>The action will not have an associated InputActionMap and actionMap will thus be <code>null</code>. Use InputActionSetupExtensions.AddAction instead if you want to add a new action to an action map.</p>
<p>The action will remain disabled after construction and thus not listen/react to input yet. Use Enable to enable the action.</p>
<div class="fragment"><div class="line"><span class="comment">// Create an action with two bindings.</span></div>
<div class="line">var action = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>();</div>
<div class="line">action.AddBinding(<span class="stringliteral">&quot;&lt;Gamepad&gt;/leftStick&quot;</span>);</div>
<div class="line">action.AddBinding(<span class="stringliteral">&quot;&lt;Mouse&gt;/delta&quot;</span>);</div>
<div class="line"> </div>
<div class="line">action.performed += ctx =&gt; Debug.Log(<span class="stringliteral">&quot;Value: &quot;</span> + ctx.ReadValue&lt;Vector2&gt;());</div>
<div class="line"> </div>
<div class="line">action.Enable();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a76d5a10b601f0956619cda9a5af9f51e" name="a76d5a10b601f0956619cda9a5af9f51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d5a10b601f0956619cda9a5af9f51e">&#9670;&#160;</a></span>InputAction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UnityEngine.InputSystem.InputAction.InputAction </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94b">InputActionType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code>default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>binding</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>interactions</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>processors</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>expectedControlType</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a free-standing action that is not part of an InputActionMap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the action. If null or empty, the action will be unnamed.</td></tr>
    <tr><td class="paramname">type</td><td>Type of action to create. Defaults to InputActionType.Value, i.e. an action that provides continuous values.</td></tr>
    <tr><td class="paramname">binding</td><td>If not null or empty, a binding with the given path will be added to the action right away. The format of the string is the as for InputBinding.path.</td></tr>
    <tr><td class="paramname">interactions</td><td>If <em>binding</em>  is not null or empty, this parameter represents the interaction to apply to the newly created binding (i.e. InputBinding.interactions). If <em>binding</em>  is not supplied, this parameter represents the interactions to apply to the action (i.e. the value of interactions).</td></tr>
    <tr><td class="paramname">processors</td><td>If <em>binding</em>  is not null or empty, this parameter represents the processors to apply to the newly created binding (i.e. InputBinding.processors). If <em>binding</em>  is not supplied, this parameter represents the processors to apply to the action (i.e. the value of processors).</td></tr>
    <tr><td class="paramname">expectedControlType</td><td>The optional expected control type for the action (i.e. expectedControlType).</td></tr>
  </table>
  </dd>
</dl>
<p>The action will not have an associated InputActionMap and actionMap will thus be <code>null</code>. Use InputActionSetupExtensions.AddAction instead if you want to add a new action to an action map.</p>
<p>The action will remain disabled after construction and thus not listen/react to input yet. Use Enable to enable the action.</p>
<p>Additional bindings can be added with InputActionSetupExtensions.AddBinding(InputAction,string,string,string,string).</p>
<div class="fragment"><div class="line"><span class="comment">// Create a button action responding to the gamepad A button.</span></div>
<div class="line">var action = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>(type: <a class="code hl_enumeration" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94b">InputActionType</a>.<a class="code hl_enumvalue" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94ba87b7760f14fbff78d8819291f36ab9a0">Button</a>, binding: <span class="stringliteral">&quot;&lt;Gamepad&gt;/buttonSouth&quot;</span>);</div>
<div class="line">action.performed += ctx =&gt; Debug.Log(<span class="stringliteral">&quot;Pressed&quot;</span>);</div>
<div class="line">action.<a class="code hl_function" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#abc6ff7728cbf947406b3c426cf82437f">Enable</a>();</div>
<div class="ttc" id="aclassUnityEngine_1_1InputSystem_1_1InputAction_html_abc6ff7728cbf947406b3c426cf82437f"><div class="ttname"><a href="classUnityEngine_1_1InputSystem_1_1InputAction.html#abc6ff7728cbf947406b3c426cf82437f">UnityEngine.InputSystem.InputAction.Enable</a></div><div class="ttdeci">void Enable()</div><div class="ttdoc">Enable the action such that it actively listens for input and runs callbacks in response.</div><div class="ttdef"><b>Definition</b> InputAction.cs:856</div></div>
<div class="ttc" id="anamespaceUnityEngine_1_1InputSystem_html_a0d0d044aae0aef15123e2f31f11ea94b"><div class="ttname"><a href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94b">UnityEngine.InputSystem.InputActionType</a></div><div class="ttdeci">InputActionType</div><div class="ttdoc">Determines the behavior with which an InputAction triggers.</div><div class="ttdef"><b>Definition</b> InputActionType.cs:130</div></div>
<div class="ttc" id="anamespaceUnityEngine_1_1InputSystem_html_a0d0d044aae0aef15123e2f31f11ea94ba87b7760f14fbff78d8819291f36ab9a0"><div class="ttname"><a href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94ba87b7760f14fbff78d8819291f36ab9a0">UnityEngine.InputSystem.InputActionType.Button</a></div><div class="ttdeci">@ Button</div><div class="ttdoc">An action that acts as a trigger.</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab89e9c5f63ab9f09fe169fd082e40c35" name="ab89e9c5f63ab9f09fe169fd082e40c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89e9c5f63ab9f09fe169fd082e40c35">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a> UnityEngine.InputSystem.InputAction.Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an identical instance of the action. </p>
<p>REVIEW: is <em>not</em> cloning IDs here really the right thing to do?</p>
<dl class="section return"><dt>Returns</dt><dd>An identical clone of the action</dd></dl>
<p>Note that if you clone an action that is part of an InputActionMap, you will not get a new action that is part of the same map. Instead, you will get a free-standing action not associated with any action map.</p>
<p>Also, note that the id of the action is not cloned. Instead, the clone will receive a new unique ID. Also, callbacks install on events such as started will not be copied over to the clone. </p>

</div>
</div>
<a id="a301a6f1f456e71eee25363f62861ff93" name="a301a6f1f456e71eee25363f62861ff93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301a6f1f456e71eee25363f62861ff93">&#9670;&#160;</a></span>Disable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnityEngine.InputSystem.InputAction.Disable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable the action such that is stop listening/responding to input. </p>
<p>If the action is already disabled, this method does nothing.</p>
<p>If the action is currently in progress, i.e. if phase is InputActionPhase.Started, the action will be canceled as part of being disabled. This means that you will see a call on canceled from within the call to <code>Disable()</code>. </p>
<dl class="section see"><dt>See also</dt><dd>enabled, Enable</dd></dl>

</div>
</div>
<a id="a5c45bb13be7dafd32a3cfd23ba85a80e" name="a5c45bb13be7dafd32a3cfd23ba85a80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c45bb13be7dafd32a3cfd23ba85a80e">&#9670;&#160;</a></span>Dispose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnityEngine.InputSystem.InputAction.Dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release internal state held on to by the action. </p>
<p>Once enabled, actions will allocate a block of state internally that they will hold on to until disposed of. For free-standing actions, that state is private to just the action. For actions that are part of InputActionMaps, the state is shared by all actions in the map and, if the map itself is part of an InputActionAsset, also by all the maps that are part of the asset.</p>
<p>Note that the internal state holds on to GC heap memory as well as memory from the unmanaged, C++ heap. </p>

</div>
</div>
<a id="abc6ff7728cbf947406b3c426cf82437f" name="abc6ff7728cbf947406b3c426cf82437f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6ff7728cbf947406b3c426cf82437f">&#9670;&#160;</a></span>Enable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnityEngine.InputSystem.InputAction.Enable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable the action such that it actively listens for input and runs callbacks in response. </p>
<p>If the action is already enabled, this method does nothing.</p>
<p>By default, actions start out disabled, i.e. with enabled being false. When enabled, two things happen.</p>
<p>First, if it hasn't already happened, an action will resolve all of its bindings to InputControls. This also happens if, since the action was last enabled, the setup of devices in the system has changed such that it may impact the action.</p>
<p>Second, for all the controls bound to an action, change monitors (see IInputStateChangeMonitor) will be added to the system. If any of the controls changes state in the future, the action will get notified and respond.</p>
<p>InputActionType.Value type actions will also perform an initial state check in the input system update following the call to Enable. This means that if any of the bound controls are already actuated and produce a non-<code>default</code> value, the action will immediately trigger in response.</p>
<p>Note that this method only enables a single action. This is also allowed for action that are part of an InputActionMap. To enable all actions in a map, call InputActionMap.Enable.</p>
<p>The InputActionMap associated with an action (if any), will immediately toggle to being enabled (see InputActionMap.enabled) as soon as the first action in the map is enabled and for as long as any action in the map is still enabled.</p>
<p>The first time an action is enabled, it will allocate a block of state internally that it will hold on to until disposed of. For free-standing actions, that state is private to just the action. For actions that are part of InputActionMaps, the state is shared by all actions in the map and, if the map itself is part of an InputActionAsset, also by all the maps that are part of the asset.</p>
<p>To dispose of the state, call Dispose.</p>
<div class="fragment"><div class="line">var gamepad = InputSystem.AddDevice&lt;<a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1Gamepad.html">Gamepad</a>&gt;();</div>
<div class="line"> </div>
<div class="line">var action = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>(type: <a class="code hl_enumeration" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94b">InputActionType</a>.<a class="code hl_enumvalue" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94ba689202409e48743b914713f96d93947c">Value</a>, binding: <span class="stringliteral">&quot;&lt;Gamepad&gt;/leftTrigger&quot;</span>);</div>
<div class="line">action.performed = ctx =&gt; Debug.Log(<span class="stringliteral">&quot;Action triggered!&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform some fake input on the gamepad. Note that the action</span></div>
<div class="line"><span class="comment">// will &lt;em&gt;NOT&lt;/em&gt; get triggered as it is not enabled.</span></div>
<div class="line"><span class="comment">// NOTE: We use Update() here only for demonstration purposes. In most cases,</span></div>
<div class="line"><span class="comment">//       it&#39;s not a good method to call directly as it basically injects artificial</span></div>
<div class="line"><span class="comment">//       input frames into the player loop. Usually a recipe for breakage.</span></div>
<div class="line">InputSystem.QueueStateEvent(gamepad, <span class="keyword">new</span> <a class="code hl_struct" href="structUnityEngine_1_1InputSystem_1_1LowLevel_1_1GamepadState.html">GamepadState</a> { leftTrigger = 0.5f });</div>
<div class="line">InputSystem.Update();</div>
<div class="line"> </div>
<div class="line">action.<a class="code hl_function" href="classUnityEngine_1_1InputSystem_1_1InputAction.html#abc6ff7728cbf947406b3c426cf82437f">Enable</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now, with the left trigger already being down and the action enabled, it will</span></div>
<div class="line"><span class="comment">// trigger in the next frame.</span></div>
<div class="line">InputSystem.Update();</div>
<div class="ttc" id="aclassUnityEngine_1_1InputSystem_1_1Gamepad_html"><div class="ttname"><a href="classUnityEngine_1_1InputSystem_1_1Gamepad.html">UnityEngine.InputSystem.Gamepad</a></div><div class="ttdoc">An Xbox-style gamepad with two sticks, a D-Pad, four face buttons, two triggers, two shoulder buttons...</div><div class="ttdef"><b>Definition</b> Gamepad.cs:372</div></div>
<div class="ttc" id="anamespaceUnityEngine_1_1InputSystem_html_a0d0d044aae0aef15123e2f31f11ea94ba689202409e48743b914713f96d93947c"><div class="ttname"><a href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94ba689202409e48743b914713f96d93947c">UnityEngine.InputSystem.InputActionType.Value</a></div><div class="ttdeci">@ Value</div><div class="ttdoc">An action that reads a single value from its connected sources. If multiple bindings actuate at the s...</div></div>
<div class="ttc" id="astructUnityEngine_1_1InputSystem_1_1LowLevel_1_1GamepadState_html"><div class="ttname"><a href="structUnityEngine_1_1InputSystem_1_1LowLevel_1_1GamepadState.html">UnityEngine.InputSystem.LowLevel.GamepadState</a></div><div class="ttdoc">Default state layout for gamepads.</div><div class="ttdef"><b>Definition</b> Gamepad.cs:34</div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>Disable, enabled</dd></dl>

</div>
</div>
<a id="a5d2970b93407d558ab7de5806599dce7" name="a5d2970b93407d558ab7de5806599dce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2970b93407d558ab7de5806599dce7">&#9670;&#160;</a></span>GetTimeoutCompletionPercentage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsafe float UnityEngine.InputSystem.InputAction.GetTimeoutCompletionPercentage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the completion percentage of the timeout (if any) running on the current interaction. </p>
<dl class="section return"><dt>Returns</dt><dd>A value &gt;= 0 (no progress) and &lt;= 1 (finished) indicating the level of completion of the currently running timeout.</dd></dl>
<p>This method is useful, for example, when providing UI feedback for an ongoing action. If, say, you have a Interactions.HoldInteraction on a binding, you might want to show a progress indicator in the UI and need to know how far into the hold the action current is. Once the hold has been started, this method will return how far into the hold the action currently is.</p>
<p>Note that if an interaction performs and stays performed (see InputInteractionContext.PerformedAndStayPerformed), the completion percentage will remain at 1 until the interaction is canceled.</p>
<p>Also note that completion is based on the progression of time and not dependent on input updates. This means that if, for example, the timeout for a Interactions.HoldInteraction has expired according the current time but the expiration has not yet been processed by an input update (thus causing the hold to perform), the returned completion percentage will still be 1. In other words, there isn't always a correlation between the current completion percentage and phase.</p>
<p>The meaning of the timeout is dependent on the interaction in play. For a Interactions.HoldInteraction, the timeout represents "completion" (that is, the time until a "hold" is considered to be performed), whereas for a Interactions.TapInteraction it represents "time to failure" (that is, the remaining time window that the interaction can be completed within).</p>
<p>Note that an interaction might run multiple timeouts in succession. One such example is Interactions.MultiTapInteraction. In this case, progression towards a single timeout does not necessarily mean progression towards completion of the whole interaction. An interaction can call InputInteractionContext.SetTotalTimeoutCompletionTime to inform the Input System of the total length of timeouts to run. If this is done, the result of the <code>GetTimeoutCompletionPercentage</code> method will return a value reflecting the progression with respect to total time.</p>
<div class="fragment"><div class="line"><span class="comment">// Scale a UI element in response to the completion of a hold on the gamepad&#39;s A button.</span></div>
<div class="line"> </div>
<div class="line">Transform uiObjectToScale;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a> holdAction;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> OnEnable()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (holdAction == <span class="keyword">null</span>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Create hold action with a 2 second timeout.</span></div>
<div class="line">        <span class="comment">// NOTE: Here we create the action in code. You can, of course, grab the action from an .inputactions</span></div>
<div class="line">        <span class="comment">//       asset created in the editor instead.</span></div>
<div class="line">        holdAction = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>(type: <a class="code hl_enumeration" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94b">InputActionType</a>.<a class="code hl_enumvalue" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94ba87b7760f14fbff78d8819291f36ab9a0">Button</a>, interactions: <span class="stringliteral">&quot;hold(duration=2)&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Show the UI object when the hold starts and hide it when it ends.</span></div>
<div class="line">        holdAction.started += _ =&gt; uiObjectToScale.SetActive(<span class="keyword">true</span>);</div>
<div class="line">        holdAction.canceled += _ =&gt; uiObjectToScale.SetActive(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If you want to play a visual effect when the action performs, you can initiate from</span></div>
<div class="line">        <span class="comment">// the performed callback.</span></div>
<div class="line">        holdAction.performed += _ =&gt; <span class="comment">/* InitiateVisualEffectWhenHoldIsComplete() *&amp;zwj;/;</span></div>
<div class="line"><span class="comment">    }</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    holdAction.Enable();</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    // Hide the UI object until the action is started.</span></div>
<div class="line"><span class="comment">    uiObjectToScale.gameObject.SetActive(false);</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">void OnDisable()</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">    holdAction.Disable();</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">void Update()</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">    var completion = holdAction.GetTimeoutCompletionPercentage();</span></div>
<div class="line"><span class="comment">    uiObjectToScale.localScale = new Vector3(1, completion, 1);</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>IInputInteraction, InputInteractionContext.SetTimeout, InputInteractionContext.SetTotalTimeoutCompletionTime</dd></dl>

</div>
</div>
<a id="a39e3c5225e7a6da527e07aeea65b6800" name="a39e3c5225e7a6da527e07aeea65b6800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e3c5225e7a6da527e07aeea65b6800">&#9670;&#160;</a></span>IsInProgress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsafe bool UnityEngine.InputSystem.InputAction.IsInProgress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the action has been InputActionPhase.Started or InputActionPhase.Performed. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the action is currently triggering.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>phase</dd></dl>

</div>
</div>
<a id="a4ba2a7836129d30d4996714c3e3f871d" name="a4ba2a7836129d30d4996714c3e3f871d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba2a7836129d30d4996714c3e3f871d">&#9670;&#160;</a></span>IsPressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsafe bool UnityEngine.InputSystem.InputAction.IsPressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the current actuation of the action has crossed the button press threshold (see InputSettings.defaultButtonPressPoint) and has not yet fallen back below the release threshold (see InputSettings.buttonReleaseThreshold). </p>
<dl class="section return"><dt>Returns</dt><dd>True if the action is considered to be in "pressed" state, false otherwise.</dd></dl>
<p>This method is different from simply reading the action's current <code>float</code> value and comparing it to the press threshold and is also different from comparing the current actuation of activeControl to it. This is because the current level of actuation might have already fallen below the press threshold but might not yet have reached the release threshold.</p>
<p>This method works with any type of action, not just buttons.</p>
<p>Also note that because this operates on the results of InputControl.EvaluateMagnitude(), it works with many kind of controls, not just buttons. For example, if an action is bound to a StickControl, the control will be considered "pressed" once the magnitude of the Vector2 of the control has crossed the press threshold.</p>
<p>Finally, note that custom button press points of controls (see <a class="el" href="classUnityEngine_1_1InputSystem_1_1Controls_1_1ButtonControl.html#aee05d5892d3fdf8a59888815420c29b6" title="The minimum value the button has to reach for it to be considered pressed.">ButtonControl.pressPoint</a>) are respected and will take precedence over InputSettings.defaultButtonPressPoint.</p>
<div class="fragment"><div class="line">var up = playerInput.actions[<span class="stringliteral">&quot;up&quot;</span>];</div>
<div class="line"><span class="keywordflow">if</span> (up.IsPressed())</div>
<div class="line">   transform.Translate(0, 10 * Time.deltaTime, 0);</div>
</div><!-- fragment --> <p>Disabled actions will always return false from this method, even if a control bound to the action is currently pressed. Also, re-enabling an action will not restore the state to when the action was disabled even if the control is still actuated. </p>
<dl class="section see"><dt>See also</dt><dd>InputSettings.defaultButtonPressPoint, <a class="el" href="classUnityEngine_1_1InputSystem_1_1Controls_1_1ButtonControl.html#aee05d5892d3fdf8a59888815420c29b6" title="The minimum value the button has to reach for it to be considered pressed.">ButtonControl.pressPoint</a>, CallbackContext.ReadValueAsButton, WasPressedThisFrame, WasReleasedThisFrame</dd></dl>

</div>
</div>
<a id="a49b189fd9d09cc28efd17c08a17eeb0c" name="a49b189fd9d09cc28efd17c08a17eeb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b189fd9d09cc28efd17c08a17eeb0c">&#9670;&#160;</a></span>ReadValue&lt; TValue &gt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsafe TValue UnityEngine.InputSystem.InputAction.ReadValue&lt; TValue &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the current value of the control that is driving this action. If no bound control is actuated, returns default(TValue), but note that binding processors are always applied. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TValue</td><td>Value type to read. Must match the value type of the binding/control that triggered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current value of the control/binding that is driving this action with all binding processors applied.</dd></dl>
<p>This method can be used as an alternative to hooking into started, performed, and/or canceled and reading out the value using CallbackContext.ReadValue&lt;TValue&gt; there. Instead, this API acts more like a polling API that can be called, for example, as part of <code>MonoBehaviour.Update</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// Let&#39;s say you have a MyControls.inputactions file with &quot;Generate C# Class&quot; enabled</span></div>
<div class="line"><span class="comment">// and it has an action map called &quot;gameplay&quot; with a &quot;move&quot; action of type Vector2.</span></div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyBehavior : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> MyControls controls;</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">float</span> moveSpeed = 4;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span> <span class="keywordtype">void</span> Awake()</div>
<div class="line">    {</div>
<div class="line">        controls = <span class="keyword">new</span> MyControls();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span> <span class="keywordtype">void</span> OnEnable()</div>
<div class="line">    {</div>
<div class="line">        controls.gameplay.Enable();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span> <span class="keywordtype">void</span> OnDisable()</div>
<div class="line">    {</div>
<div class="line">        controls.gameplay.Disable();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span> <span class="keywordtype">void</span> Update()</div>
<div class="line">    {</div>
<div class="line">        var moveVector = controls.gameplay.move.ReadValue&lt;Vector2&gt;() * (moveSpeed * Time.deltaTime);</div>
<div class="line">        <span class="comment">//...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> <p>If the action has button-like behavior, then triggered is usually a better alternative to reading out a float and checking if it is above the button press point. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidOperationException</td><td>The given <em>TValue</em>  type does not match the value type of the control or composite currently driving the action.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>triggered, ReadValueAsObject, CallbackContext.ReadValue&lt;TValue&gt;</dd></dl>
<div class="typeconstraint">
<dl><dt><b>Type Constraints</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>TValue</em></td><td>&#160;:</td><td valign="top"><em>struct</em></td><td>&#160;</td></tr>
</table>
</dd>
</dl>
</div>

</div>
</div>
<a id="a46b48d7c58238d51f0ff1c708aa360da" name="a46b48d7c58238d51f0ff1c708aa360da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b48d7c58238d51f0ff1c708aa360da">&#9670;&#160;</a></span>ReadValueAsObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsafe object UnityEngine.InputSystem.InputAction.ReadValueAsObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as ReadValue&lt;TValue&gt; but read the value without having to know the value type of the action. </p>
<dl class="section return"><dt>Returns</dt><dd>The current value of the action or <code>null</code> if the action is not currently in InputActionPhase.Started or InputActionPhase.Performed phase.</dd></dl>
<p>This method allocates GC memory and is thus not a good choice for getting called as part of gameplay logic. </p>
<dl class="section see"><dt>See also</dt><dd>ReadValue&lt;TValue&gt;, InputAction.CallbackContext.ReadValueAsObject</dd></dl>

</div>
</div>
<a id="a734e734be5da00df41bb4a0c02ffe7a5" name="a734e734be5da00df41bb4a0c02ffe7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734e734be5da00df41bb4a0c02ffe7a5">&#9670;&#160;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UnityEngine.InputSystem.InputAction.Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the action state to default. </p>
<p>This method can be used to forcibly cancel an action even while it is in progress. Note that unlike disabling an action, for example, this also effects APIs such as WasPressedThisFrame.</p>
<p>Note that invoking this method will not modify enabled state. </p>
<dl class="section see"><dt>See also</dt><dd>inProgress, phase, Enable, Disable</dd></dl>

</div>
</div>
<a id="a30a705ae3957bdb7d38380b7528b44c9" name="a30a705ae3957bdb7d38380b7528b44c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a705ae3957bdb7d38380b7528b44c9">&#9670;&#160;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">override string UnityEngine.InputSystem.InputAction.ToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string version of the action. Mainly useful for debugging. </p>
<dl class="section return"><dt>Returns</dt><dd>A string version of the action.</dd></dl>

</div>
</div>
<a id="a1968a212ee4e88950b4f1f15043a9d42" name="a1968a212ee4e88950b4f1f15043a9d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1968a212ee4e88950b4f1f15043a9d42">&#9670;&#160;</a></span>WasPerformedThisFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsafe bool UnityEngine.InputSystem.InputAction.WasPerformedThisFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether phase was InputActionPhase.Performed at any point in the current frame. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the action performed this frame.</dd></dl>
<p>This method is different from WasPressedThisFrame in that it depends directly on the interaction(s) driving the action (including the default interaction if no specific interaction has been added to the action or binding).</p>
<p>For example, let's say the action is bound to the space bar and that the binding has a Interactions.HoldInteraction assigned to it. In the frame where the space bar is pressed, WasPressedThisFrame will be true (because the button/key is now pressed) but <code>WasPerformedThisFrame</code> will still be false (because the hold has not been performed yet). Only after the hold time has expired will <code>WasPerformedThisFrame</code> be true and only in the frame where the hold performed.</p>
<p>This is different from checking phase directly as the action might have already progressed to a different phase after performing. In other words, even if an action performed in a frame, phase might no longer be InputActionPhase.Performed, whereas <code>WasPerformedThisFrame</code> will remain true for the entirety of the frame regardless of what else the action does.</p>
<p>Unlike ReadValue&lt;TValue&gt;, which will reset when the action goes back to waiting state, this property will stay true for the duration of the current frame (that is, until the next InputSystem.Update runs) as long as the action was triggered at least once.</p>
<div class="fragment"><div class="line">var warp = playerInput.actions[<span class="stringliteral">&quot;Warp&quot;</span>];</div>
<div class="line"><span class="keywordflow">if</span> (warp.WasPerformedThisFrame())</div>
<div class="line">    InitiateWarp();</div>
</div><!-- fragment --> <p>This method will disregard whether the action is currently enabled or disabled. It will keep returning true for the duration of the frame even if the action was subsequently disabled in the frame.</p>
<p>The meaning of "frame" is either the current "dynamic" update (<code>MonoBehaviour.Update</code>) or the current fixed update (<code>MonoBehaviour.FixedUpdate</code>) depending on the value of the InputSettings.updateMode setting. </p>
<dl class="section see"><dt>See also</dt><dd>WasPressedThisFrame, phase</dd></dl>

</div>
</div>
<a id="a7776c9dbaab7db1f49493c6e7e8c4fbb" name="a7776c9dbaab7db1f49493c6e7e8c4fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7776c9dbaab7db1f49493c6e7e8c4fbb">&#9670;&#160;</a></span>WasPressedThisFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsafe bool UnityEngine.InputSystem.InputAction.WasPressedThisFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the action's value crossed the press threshold (see InputSettings.defaultButtonPressPoint) at any point in the frame. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the action was pressed this frame.</dd></dl>
<p>This method is different from WasPerformedThisFrame in that it is not bound to phase. Instead, if the action's level of actuation (that is, the level of magnitude &ndash; see InputControl.EvaluateMagnitude() &ndash; of the control(s) bound to the action) crossed the press threshold (see InputSettings.defaultButtonPressPoint) at any point in the frame, this method will return true. It will do so even if there is an interaction on the action that has not yet performed the action in response to the press.</p>
<p>This method works with any type of action, not just buttons.</p>
<p>Also note that because this operates on the results of InputControl.EvaluateMagnitude(), it works with many kind of controls, not just buttons. For example, if an action is bound to a StickControl, the control will be considered "pressed" once the magnitude of the Vector2 of the control has crossed the press threshold.</p>
<p>Finally, note that custom button press points of controls (see <a class="el" href="classUnityEngine_1_1InputSystem_1_1Controls_1_1ButtonControl.html#aee05d5892d3fdf8a59888815420c29b6" title="The minimum value the button has to reach for it to be considered pressed.">ButtonControl.pressPoint</a>) are respected and will take precedence over InputSettings.defaultButtonPressPoint.</p>
<div class="fragment"><div class="line">var fire = playerInput.actions[<span class="stringliteral">&quot;fire&quot;</span>];</div>
<div class="line"><span class="keywordflow">if</span> (fire.WasPressedThisFrame() &amp;amp;&amp;amp; fire.IsPressed())</div>
<div class="line">    StartFiring();</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (fire.WasReleasedThisFrame())</div>
<div class="line">    StopFiring();</div>
</div><!-- fragment --> <p>This method will disregard whether the action is currently enabled or disabled. It will keep returning true for the duration of the frame even if the action was subsequently disabled in the frame.</p>
<p>The meaning of "frame" is either the current "dynamic" update (<code>MonoBehaviour.Update</code>) or the current fixed update (<code>MonoBehaviour.FixedUpdate</code>) depending on the value of the InputSettings.updateMode setting. </p>
<dl class="section see"><dt>See also</dt><dd>IsPressed, WasReleasedThisFrame, CallbackContext.ReadValueAsButton, WasPerformedThisFrame</dd></dl>

</div>
</div>
<a id="aa0aa02b5124108b0fd9ecc74e919ee9b" name="aa0aa02b5124108b0fd9ecc74e919ee9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aa02b5124108b0fd9ecc74e919ee9b">&#9670;&#160;</a></span>WasReleasedThisFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsafe bool UnityEngine.InputSystem.InputAction.WasReleasedThisFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the action's value crossed the release threshold (see InputSettings.buttonReleaseThreshold) at any point in the frame after being in pressed state. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the action was released this frame.</dd></dl>
<p>This method works with any type of action, not just buttons.</p>
<p>Also note that because this operates on the results of InputControl.EvaluateMagnitude(), it works with many kind of controls, not just buttons. For example, if an action is bound to a StickControl, the control will be considered "pressed" once the magnitude of the Vector2 of the control has crossed the press threshold.</p>
<p>Finally, note that custom button press points of controls (see <a class="el" href="classUnityEngine_1_1InputSystem_1_1Controls_1_1ButtonControl.html#aee05d5892d3fdf8a59888815420c29b6" title="The minimum value the button has to reach for it to be considered pressed.">ButtonControl.pressPoint</a>) are respected and will take precedence over InputSettings.defaultButtonPressPoint.</p>
<div class="fragment"><div class="line">var fire = playerInput.actions[<span class="stringliteral">&quot;fire&quot;</span>];</div>
<div class="line"><span class="keywordflow">if</span> (fire.WasPressedThisFrame() &amp;amp;&amp;amp; fire.IsPressed())</div>
<div class="line">    StartFiring();</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (fire.WasReleasedThisFrame())</div>
<div class="line">    StopFiring();</div>
</div><!-- fragment --> <p>This method will disregard whether the action is currently enabled or disabled. It will keep returning true for the duration of the frame even if the action was subsequently disabled in the frame.</p>
<p>The meaning of "frame" is either the current "dynamic" update (<code>MonoBehaviour.Update</code>) or the current fixed update (<code>MonoBehaviour.FixedUpdate</code>) depending on the value of the InputSettings.updateMode setting. </p>
<dl class="section see"><dt>See also</dt><dd>IsPressed, WasPressedThisFrame, CallbackContext.ReadValueAsButton, WasPerformedThisFrame</dd></dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="ae6817835d32520aa1433e7119c6e30e8" name="ae6817835d32520aa1433e7119c6e30e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6817835d32520aa1433e7119c6e30e8">&#9670;&#160;</a></span>actionMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUnityEngine_1_1InputSystem_1_1InputActionMap.html">InputActionMap</a> UnityEngine.InputSystem.InputAction.actionMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The map the action belongs to. </p>
<p>InputActionMap that the action belongs to or null.</p>
<p>If the action is a loose action created in code, this will be <code>null</code>.</p>
<div class="fragment"><div class="line">var action1 = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>(); <span class="comment">// action1.actionMap will be null</span></div>
<div class="line"> </div>
<div class="line">var actionMap = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputActionMap.html">InputActionMap</a>();</div>
<div class="line">var action2 = actionMap.AddAction(<span class="stringliteral">&quot;action&quot;</span>); <span class="comment">// action2.actionMap will point to actionMap</span></div>
<div class="ttc" id="aclassUnityEngine_1_1InputSystem_1_1InputActionMap_html"><div class="ttname"><a href="classUnityEngine_1_1InputSystem_1_1InputActionMap.html">UnityEngine.InputSystem.InputActionMap</a></div><div class="ttdoc">A mechanism for collecting a series of input actions (see InputAction) and treating them as a group.</div><div class="ttdef"><b>Definition</b> InputActionMap.cs:73</div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>InputActionSetupExtensions.AddAction</dd></dl>

</div>
</div>
<a id="a472cf9d7e67051b780bca5df73c7bb84" name="a472cf9d7e67051b780bca5df73c7bb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472cf9d7e67051b780bca5df73c7bb84">&#9670;&#160;</a></span>activeControl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsafe <a class="el" href="classUnityEngine_1_1InputSystem_1_1InputControl.html">InputControl</a> UnityEngine.InputSystem.InputAction.activeControl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently active control that is driving the action. Null while the action is in waiting (InputActionPhase.Waiting) or canceled (InputActionPhase.Canceled) state. Otherwise the control that last had activity on it which wasn't ignored. </p>
<p>Note that the control's value does not necessarily correspond to the value of the action (ReadValue&lt;TValue&gt;) as the control may be part of a composite. </p>
<dl class="section see"><dt>See also</dt><dd>CallbackContext.control</dd></dl>

</div>
</div>
<a id="a41caa3a44bc876781c5b1bcb04622cd2" name="a41caa3a44bc876781c5b1bcb04622cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41caa3a44bc876781c5b1bcb04622cd2">&#9670;&#160;</a></span>bindingMask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUnityEngine_1_1InputSystem_1_1InputBinding.html">InputBinding</a>? UnityEngine.InputSystem.InputAction.bindingMask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An optional mask that determines which bindings of the action to enable and which to ignore. </p>
<p>Optional mask that determines which bindings on the action to enable.</p>
<p>Binding masks can be applied at three different levels: for an entire asset through InputActionAsset.bindingMask, for a specific map through InputActionMap.bindingMask, and for single actions through this property. By default, none of the masks will be set (i.e. they will be <code>null</code>).</p>
<p>When an action is enabled, all the binding masks that apply to it are taken into account. Specifically, this means that any given binding on the action will be enabled only if it matches the mask applied to the asset, the mask applied to the map that contains the action, and the mask applied to the action itself. All the masks are individually optional.</p>
<p>Masks are matched against bindings using InputBinding.Matches.</p>
<p>Note that if you modify the masks applicable to an action while it is enabled, the action's controls will get updated immediately to respect the mask. To avoid repeated binding resolution, it is most efficient to apply binding masks before enabling actions.</p>
<p>Binding masks are non-destructive. All the bindings on the action are left in place. Setting a mask will not affect the value of the bindings property.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a free-standing action with two bindings, one in the</span></div>
<div class="line"><span class="comment">// &quot;Keyboard&quot; group and one in the &quot;Gamepad&quot; group.</span></div>
<div class="line">var action = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>();</div>
<div class="line">action.AddBinding(<span class="stringliteral">&quot;&lt;Gamepad&gt;/buttonSouth&quot;</span>, groups: <span class="stringliteral">&quot;Gamepad&quot;</span>);</div>
<div class="line">action.AddBinding(<span class="stringliteral">&quot;&lt;Keyboard&gt;/space&quot;</span>, groups: <span class="stringliteral">&quot;Keyboard&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// By default, all bindings will be enabled. This means if both</span></div>
<div class="line"><span class="comment">// a keyboard and gamepad (or several of them) is present, the action</span></div>
<div class="line"><span class="comment">// will respond to input from all of them.</span></div>
<div class="line">action.Enable();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// With a binding mask we can restrict the action to just specific</span></div>
<div class="line"><span class="comment">// bindings. For example, to only enable the gamepad binding:</span></div>
<div class="line">action.bindingMask = <a class="code hl_struct" href="structUnityEngine_1_1InputSystem_1_1InputBinding.html">InputBinding</a>.MaskByGroup(<span class="stringliteral">&quot;Gamepad&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note that we can mask by more than just by group. Masking by path</span></div>
<div class="line"><span class="comment">// or by action as well as a combination of these is also possible.</span></div>
<div class="line"><span class="comment">// We could, for example, mask for just a specific binding path:</span></div>
<div class="line">action.bindingMask = <span class="keyword">new</span> <a class="code hl_struct" href="structUnityEngine_1_1InputSystem_1_1InputBinding.html">InputBinding</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Select the keyboard binding based on its specific path.</span></div>
<div class="line">    path = <span class="stringliteral">&quot;&lt;Keyboard&gt;/space&quot;</span></div>
<div class="line">};</div>
<div class="ttc" id="astructUnityEngine_1_1InputSystem_1_1InputBinding_html"><div class="ttname"><a href="structUnityEngine_1_1InputSystem_1_1InputBinding.html">UnityEngine.InputSystem.InputBinding</a></div><div class="ttdoc">A mapping of controls to an action.</div><div class="ttdef"><b>Definition</b> InputBinding.cs:49</div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>InputBinding.MaskByGroup, InputActionMap.bindingMask, InputActionAsset.bindingMask</dd></dl>

</div>
</div>
<a id="a44fdaf3ff9ffc22609a9df942372d9bb" name="a44fdaf3ff9ffc22609a9df942372d9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fdaf3ff9ffc22609a9df942372d9bb">&#9670;&#160;</a></span>bindings</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUnityEngine_1_1InputSystem_1_1Utilities_1_1ReadOnlyArray.html">ReadOnlyArray</a>&lt;<a class="el" href="structUnityEngine_1_1InputSystem_1_1InputBinding.html">InputBinding</a>&gt; UnityEngine.InputSystem.InputAction.bindings</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of bindings associated with the action. </p>
<p>List of bindings for the action.</p>
<p>This list contains all bindings from InputActionMap.bindings of the action's actionMap that reference the action through their InputBinding.action property.</p>
<p>Note that on the first call, the list may have to be extracted from the action map first which may require allocating GC memory. However, once initialized, no further GC allocation hits should occur. If the binding setup on the map is changed, re-initialization may be required. </p>
<dl class="section see"><dt>See also</dt><dd>InputActionMap.bindings</dd></dl>

</div>
</div>
<a id="a905374d6d7af6dc57a54acfa22018976" name="a905374d6d7af6dc57a54acfa22018976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905374d6d7af6dc57a54acfa22018976">&#9670;&#160;</a></span>canceled</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Action&lt;<a class="el" href="structUnityEngine_1_1InputSystem_1_1InputAction_1_1CallbackContext.html">CallbackContext</a>&gt; UnityEngine.InputSystem.InputAction.canceled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">add</span><span class="mlabel">remove</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event that is triggered when the action has been started but then canceled before being fully performed. </p>
<p>See phase for details of how an action progresses through phases and triggers this callback. </p>
<p>InputActionPhase.Canceled </p>

</div>
</div>
<a id="a8e3f5d3329be13ca8474314137045af4" name="a8e3f5d3329be13ca8474314137045af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3f5d3329be13ca8474314137045af4">&#9670;&#160;</a></span>controls</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUnityEngine_1_1InputSystem_1_1Utilities_1_1ReadOnlyArray.html">ReadOnlyArray</a>&lt;<a class="el" href="classUnityEngine_1_1InputSystem_1_1InputControl.html">InputControl</a>&gt; UnityEngine.InputSystem.InputAction.controls</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of controls to which the action's bindings resolve. </p>
<p>Controls resolved from the action's bindings.</p>
<p>This property can be queried whether the action is enabled or not and will return the set of controls that match the action's bindings according to the current setup of binding masks (bindingMask) and device restrictions (InputActionMap.devices).</p>
<p>Note that internally, controls are not stored on a per-action basis. This means that on the first read of this property, the list of controls for just the action may have to be extracted which in turn may allocate GC memory. After the first read, no further GC allocations should occur except if the set of controls is changed (e.g. by changing the binding mask or by adding/removing devices to/from the system).</p>
<p>If the property is queried when the action has not been enabled yet, the system will first resolve controls on the action (and for all actions in the map and/or the asset). See <a href="../manual/ActionBindings.html#binding-resolution">Binding Resolution</a> in the manual for details.</p>
<p>To map a control in this array to an index into bindings, use InputActionRebindingExtensions.GetBindingIndexForControl.</p>
<div class="fragment"><div class="line"><span class="comment">// Map control list to binding indices.</span></div>
<div class="line">var bindingIndices = myAction.controls.Select(c =&gt; myAction.GetBindingIndexForControl(c));</div>
</div><!-- fragment --> <p>Note that this array will not contain the same control multiple times even if more than one binding on an action references the same control.</p>
<div class="fragment"><div class="line">var action1 = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>();</div>
<div class="line">action1.AddBinding(<span class="stringliteral">&quot;&lt;Gamepad&gt;/buttonSouth&quot;</span>);</div>
<div class="line">action1.AddBinding(<span class="stringliteral">&quot;&lt;Gamepad&gt;/buttonSouth&quot;</span>); <span class="comment">// This binding will be ignored.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Contains only one instance of buttonSouth which is associated</span></div>
<div class="line"><span class="comment">// with the first binding (at index #0).</span></div>
<div class="line">var action1Controls = action1.controls;</div>
<div class="line"> </div>
<div class="line">var action2 = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>();</div>
<div class="line">action2.AddBinding(<span class="stringliteral">&quot;&lt;Gamepad&gt;/buttonSouth&quot;</span>);</div>
<div class="line"><span class="comment">// Add a binding that implicitly matches the first binding, too. When binding resolution</span></div>
<div class="line"><span class="comment">// happens, this binding will only receive buttonNorth, buttonWest, and buttonEast, but not</span></div>
<div class="line"><span class="comment">// buttonSouth as the first binding already received that control.</span></div>
<div class="line">action2.AddBinding(<span class="stringliteral">&quot;&lt;Gamepad&gt;/button*&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Contains only all four face buttons (buttonSouth, buttonNorth, buttonEast, buttonWest)</span></div>
<div class="line"><span class="comment">// but buttonSouth is associated with the first button and only buttonNorth, buttonEast,</span></div>
<div class="line"><span class="comment">// and buttonWest are associated with the second binding.</span></div>
<div class="line">var action2Controls = action2.controls;</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>InputActionRebindingExtensions.GetBindingIndexForControl, bindings</dd></dl>

</div>
</div>
<a id="a10b7ab479ef1419726f2d05927fd1b70" name="a10b7ab479ef1419726f2d05927fd1b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b7ab479ef1419726f2d05927fd1b70">&#9670;&#160;</a></span>enabled</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UnityEngine.InputSystem.InputAction.enabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the action is currently enabled, i.e. responds to input, or not. </p>
<p>True if the action is currently enabled.</p>
<p>An action is enabled by either calling Enable on it directly or by calling InputActionMap.Enable on the InputActionMap containing the action. When enabled, an action will listen for changes on the controls it is bound to and trigger callbacks such as started, performed, and canceled in response. </p>
<dl class="section see"><dt>See also</dt><dd>Enable, Disable, InputActionMap.Enable, InputActionMap.Disable, InputSystem.ListEnabledActions()</dd></dl>

</div>
</div>
<a id="ab0330ac2a9ede3454cb0c092ac0a7bcb" name="ab0330ac2a9ede3454cb0c092ac0a7bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0330ac2a9ede3454cb0c092ac0a7bcb">&#9670;&#160;</a></span>expectedControlType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string UnityEngine.InputSystem.InputAction.expectedControlType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of control layout expected for controls bound to this action. </p>
<p>This is optional and is null by default.</p>
<p>Constraining an action to a particular control layout allows determine the value type and expected input behavior of an action without being reliant on any particular binding. </p>

</div>
</div>
<a id="a20c55a69282fe033ba0ca4ce706e4a68" name="a20c55a69282fe033ba0ca4ce706e4a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c55a69282fe033ba0ca4ce706e4a68">&#9670;&#160;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Guid UnityEngine.InputSystem.InputAction.id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A stable, unique identifier for the action. </p>
<p>Unique ID of the action.</p>
<p>This can be used instead of the name to refer to the action. Doing so allows referring to the action such that renaming the action does not break references. </p>

</div>
</div>
<a id="ad3f170acb40585d0ce4f6c2243b5b213" name="ad3f170acb40585d0ce4f6c2243b5b213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f170acb40585d0ce4f6c2243b5b213">&#9670;&#160;</a></span>inProgress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UnityEngine.InputSystem.InputAction.inProgress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the action is currently in InputActionPhase.Started or InputActionPhase.Performed phase. False in all other cases. </p>
<p>phase </p>

</div>
</div>
<a id="a625a03ad3baab2c78b68cc782ca25458" name="a625a03ad3baab2c78b68cc782ca25458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625a03ad3baab2c78b68cc782ca25458">&#9670;&#160;</a></span>interactions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string UnityEngine.InputSystem.InputAction.interactions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interactions applied to every binding on the action. </p>
<p>Interactions added to all bindings on the action.</p>
<p>This property is equivalent to appending the same string to the InputBinding.interactions field of every binding that targets the action. It is thus simply a means of avoiding the need configure the same interaction the same way on every binding in case it uniformly applies to all of them.</p>
<div class="fragment"><div class="line">var action = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>(interactions: <span class="stringliteral">&quot;press&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Both of the following bindings will implicitly have a</span></div>
<div class="line"><span class="comment">// Press interaction applied to them.</span></div>
<div class="line">action.AddBinding(<span class="stringliteral">&quot;&lt;Gamepad&gt;/buttonSouth&quot;</span>);</div>
<div class="line">action.AddBinding(<span class="stringliteral">&quot;&lt;Joystick&gt;/trigger&quot;</span>);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>InputBinding.interactions, IInputInteraction, InputSystem.RegisterInteraction&lt;T&gt;</dd></dl>

</div>
</div>
<a id="a18e68eda84c66e46fc7908fe67b8ffce" name="a18e68eda84c66e46fc7908fe67b8ffce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e68eda84c66e46fc7908fe67b8ffce">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string UnityEngine.InputSystem.InputAction.name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of the action. </p>
<p>Plain-text name of the action.</p>
<p>Can be null for anonymous actions created in code.</p>
<p>If the action is part of an InputActionMap, it will have a name and the name will be unique in the map. The name is just the name of the action alone, not a "mapName/actionName" combination.</p>
<p>The name should not contain slashes or dots but can contain spaces and other punctuation.</p>
<p>An action can be renamed after creation using InputActionSetupExtensions.Rename.. </p>
<dl class="section see"><dt>See also</dt><dd>InputActionMap.FindAction(string,bool)</dd></dl>

</div>
</div>
<a id="a11c046d8fb911d300e30e67827222c1f" name="a11c046d8fb911d300e30e67827222c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c046d8fb911d300e30e67827222c1f">&#9670;&#160;</a></span>performed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Action&lt;<a class="el" href="structUnityEngine_1_1InputSystem_1_1InputAction_1_1CallbackContext.html">CallbackContext</a>&gt; UnityEngine.InputSystem.InputAction.performed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">add</span><span class="mlabel">remove</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event that is triggered when the action has been fully performed. </p>
<p>See phase for details of how an action progresses through phases and triggers this callback. </p>
<p>InputActionPhase.Performed </p>

</div>
</div>
<a id="a86bd545c9dfe1fb0200e296c44389e57" name="a86bd545c9dfe1fb0200e296c44389e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bd545c9dfe1fb0200e296c44389e57">&#9670;&#160;</a></span>phase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceUnityEngine_1_1InputSystem.html#aecc012480a29c4b720a87b8465f34182">InputActionPhase</a> UnityEngine.InputSystem.InputAction.phase</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current phase of the action. </p>
<p>When listening for control input and when responding to control value changes, actions will go through several possible phases.</p>
<p>In general, when an action starts receiving input, it will go to InputActionPhase.Started and when it stops receiving input, it will go to InputActionPhase.Canceled. When InputActionPhase.Performed is used depends primarily on the type of action. InputActionType.Value will trigger InputActionPhase.Performed whenever the value of the control changes (including the first time; i.e. it will first trigger InputActionPhase.Started and then InputActionPhase.Performed right after) whereas InputActionType.Button will trigger InputActionPhase.Performed as soon as the button press threshold (InputSettings.defaultButtonPressPoint) has been crossed.</p>
<p>Note that both interactions and the action type can affect the phases that an action goes through. InputActionType.PassThrough actions will only ever use InputActionPhase.Performed and not go to InputActionPhase.Started or InputActionPhase.Canceled (as pass-through actions do not follow the start-performed-canceled model in general). Also, interactions can choose their</p>
<p>While an action is disabled, its phase is InputActionPhase.Disabled. </p>

</div>
</div>
<a id="a02b761c2f6c76c80c3c4b1cd396df3c4" name="a02b761c2f6c76c80c3c4b1cd396df3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b761c2f6c76c80c3c4b1cd396df3c4">&#9670;&#160;</a></span>processors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string UnityEngine.InputSystem.InputAction.processors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processors applied to every binding on the action. </p>
<p>Processors added to all bindings on the action.</p>
<p>This property is equivalent to appending the same string to the InputBinding.processors field of every binding that targets the action. It is thus simply a means of avoiding the need configure the same processor the same way on every binding in case it uniformly applies to all of them.</p>
<div class="fragment"><div class="line">var action = <span class="keyword">new</span> <a class="code hl_class" href="classUnityEngine_1_1InputSystem_1_1InputAction.html">InputAction</a>(processors: <span class="stringliteral">&quot;scaleVector2(x=2, y=2)&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Both of the following bindings will implicitly have a</span></div>
<div class="line"><span class="comment">// ScaleVector2Processor applied to them.</span></div>
<div class="line">action.AddBinding(<span class="stringliteral">&quot;&lt;Gamepad&gt;/leftStick&quot;</span>);</div>
<div class="line">action.AddBinding(<span class="stringliteral">&quot;&lt;Joystick&gt;/stick&quot;</span>);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>InputBinding.processors, InputProcessor, InputSystem.RegisterProcessor&lt;T&gt;</dd></dl>

</div>
</div>
<a id="a5fecf2acd129fa0922452ecf32527cdd" name="a5fecf2acd129fa0922452ecf32527cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fecf2acd129fa0922452ecf32527cdd">&#9670;&#160;</a></span>started</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Action&lt;<a class="el" href="structUnityEngine_1_1InputSystem_1_1InputAction_1_1CallbackContext.html">CallbackContext</a>&gt; UnityEngine.InputSystem.InputAction.started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">add</span><span class="mlabel">remove</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event that is triggered when the action has been started. </p>
<p>See phase for details of how an action progresses through phases and triggers this callback. </p>
<p>InputActionPhase.Started </p>

</div>
</div>
<a id="ae559389a3ace0bdfc463ac56bf57632b" name="ae559389a3ace0bdfc463ac56bf57632b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae559389a3ace0bdfc463ac56bf57632b">&#9670;&#160;</a></span>triggered</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UnityEngine.InputSystem.InputAction.triggered</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to WasPerformedThisFrame. </p>
<p>TODO: Obsolete and drop this when we can break API</p>
<dl class="section see"><dt>See also</dt><dd>WasPerformedThisFrame</dd></dl>

</div>
</div>
<a id="a4034bbebc91379913a9da5600a8a3491" name="a4034bbebc91379913a9da5600a8a3491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4034bbebc91379913a9da5600a8a3491">&#9670;&#160;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceUnityEngine_1_1InputSystem.html#a0d0d044aae0aef15123e2f31f11ea94b">InputActionType</a> UnityEngine.InputSystem.InputAction.type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Behavior type of the action. </p>
<p>General behavior type of the action.</p>
<p>Determines how the action gets triggered in response to control value changes.</p>
<p>For details about how the action type affects an action, see InputActionType. </p>

</div>
</div>
<a id="a2978b2fcba4145ce4213df097c298a98" name="a2978b2fcba4145ce4213df097c298a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2978b2fcba4145ce4213df097c298a98">&#9670;&#160;</a></span>wantsInitialStateCheck</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UnityEngine.InputSystem.InputAction.wantsInitialStateCheck</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the action wants a state check on its bound controls as soon as it is enabled. This is always true for InputActionType.Value actions but can optionally be enabled for InputActionType.Button or InputActionType.PassThrough actions. </p>
<p>Usually, when an action is enabled (e.g. via Enable), it will start listening for input and then trigger once the first input arrives. However, controls bound to an action may already be actuated when an action is enabled. For example, if a "jump" action is bound to Keyboard.spaceKey, the space bar may already be pressed when the jump action is enabled.</p>
<p>InputActionType.Value actions handle this differently by immediately performing an "initial state check" in the next input update (see InputSystem.Update) after being enabled. If any of the bound controls is already actuated, the action will trigger right away &ndash; even with no change in state on the controls.</p>
<p>This same behavior can be enabled explicitly for InputActionType.Button and InputActionType.PassThrough actions using this property. </p>
<dl class="section see"><dt>See also</dt><dd>Enable, InputActionType.Value</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ARPetPals/Library/PackageCache/com.unity.inputsystem@1.5.1/InputSystem/Actions/<b>InputAction.cs</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
